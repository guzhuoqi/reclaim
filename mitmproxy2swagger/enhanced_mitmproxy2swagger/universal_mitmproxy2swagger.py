#!/usr/bin/env python3
"""
通用银行数据分析器
Universal Bank Data Analyzer using mitmproxy2swagger

基于通用规则引擎的增强版mitmproxy2swagger，支持更广泛的银行和数据格式。
不再按银行分类，而是使用统一的7条核心规则进行数据提取和分析。

主要特性：
- 集成通用余额提取规则引擎
- 支持多种数据格式（HTML、JSON、JavaScript等）
- 智能银行识别和货币处理
- 统一的数据验证和质量保证
- 生成增强的OpenAPI规范
"""

import argparse
import json
import os
import sys
import traceback
import logging
from typing import Any, Optional, Sequence, Dict, List
from datetime import datetime
from pathlib import Path

import msgpack
import ruamel.yaml
from mitmproxy.exceptions import FlowReadException

# 导入原始mitmproxy2swagger模块
from mitmproxy2swagger import console_util, swagger_util
from mitmproxy2swagger.har_capture_reader import HarCaptureReader, har_archive_heuristic
from mitmproxy2swagger.mitmproxy_capture_reader import (
    MitmproxyCaptureReader,
    mitmproxy_dump_file_huristic,
)

# 导入我们的通用规则引擎
from universal_balance_rules import UniversalBalanceRulesEngine, BalanceData


def setup_logging():
    """设置日志配置"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler('universal_mitmproxy2swagger.log')
        ]
    )
    return logging.getLogger(__name__)


class UniversalSwaggerGenerator:
    """通用Swagger生成器"""
    
    def __init__(self, include_examples=False, include_headers=False):
        self.rules_engine = UniversalBalanceRulesEngine()
        self.include_examples = include_examples
        self.include_headers = include_headers
        self.logger = logging.getLogger(__name__)
        
        # 统计信息
        self.stats = {
            'total_flows': 0,
            'processed_flows': 0,
            'balance_apis_found': 0,
            'extraction_success': 0,
            'extraction_failed': 0,
            'currencies_detected': set(),
            'banks_detected': set()
        }
    
    def process_flows(self, flows, existing_swagger=None):
        """处理流量数据并生成swagger规范"""
        self.logger.info("开始处理流量数据...")
        
        swagger_spec = existing_swagger or self._create_base_swagger()
        processed_endpoints = {}
        
        for req in flows:
            self.stats['total_flows'] += 1
            
            try:
                # 基础流量处理
                endpoint_data = self._process_single_flow(req)
                if not endpoint_data:
                    continue
                
                self.stats['processed_flows'] += 1
                
                # 使用通用规则引擎分析
                balance_analysis = self._analyze_with_rules_engine(req)
                
                if balance_analysis and balance_analysis.get('extracted_balances'):
                    self.stats['balance_apis_found'] += 1
                    self.stats['extraction_success'] += 1
                    
                    # 更新统计信息
                    bank_region = balance_analysis.get('bank_info', {}).get('region')
                    if bank_region:
                        self.stats['banks_detected'].add(bank_region)
                    
                    for balance in balance_analysis.get('extracted_balances', []):
                        currency = balance.get('currency')
                        if currency:
                            self.stats['currencies_detected'].add(currency)
                    
                    # 增强endpoint数据
                    endpoint_data = self._enhance_endpoint_with_balance_data(
                        endpoint_data, balance_analysis
                    )
                
                # 添加到swagger规范
                self._add_endpoint_to_swagger(swagger_spec, endpoint_data)
                
            except Exception as e:
                self.stats['extraction_failed'] += 1
                self.logger.error(f"处理流量时出错: {str(e)}")
                if self.logger.level <= logging.DEBUG:
                    self.logger.debug(traceback.format_exc())
        
        # 添加统计信息到swagger
        self._add_stats_to_swagger(swagger_spec)
        
        self.logger.info(f"处理完成: {self.stats}")
        return swagger_spec
    
    def _create_base_swagger(self):
        """创建基础swagger规范"""
        return {
            'openapi': '3.0.0',
            'info': {
                'title': 'Universal Bank API Analysis',
                'description': 'Generated by Universal mitmproxy2swagger with balance extraction rules',
                'version': '1.0.0',
                'x-generator': 'universal-mitmproxy2swagger',
                'x-generation-time': datetime.now().isoformat(),
                'x-rules-engine': 'UniversalBalanceRulesEngine'
            },
            'servers': [],
            'paths': {},
            'components': {
                'schemas': {
                    'BalanceData': {
                        'type': 'object',
                        'properties': {
                            'amount': {'type': 'string', 'description': 'Balance amount'},
                            'currency': {'type': 'string', 'description': 'Currency code'},
                            'account_type': {'type': 'string', 'description': 'Account type'},
                            'confidence': {'type': 'number', 'description': 'Extraction confidence'},
                            'extraction_method': {'type': 'string', 'description': 'Method used for extraction'}
                        }
                    }
                }
            }
        }
    
    def _process_single_flow(self, req):
        """处理单个流量 - 使用与原脚本相同的接口"""
        try:
            # 使用原脚本相同的方法调用
            method = req.get_method()
            url = req.get_url()
            status = req.get_response_status_code()
            
            if not url or not method:
                return None
                
            # 调试信息：记录所有响应状态码
            self.logger.debug(f"处理流量: {method} {url} -> {status}")
            
            # 更宽松的状态码检查 - 包括2xx和3xx
            if status and not (200 <= status < 400):
                return None
            
            # 响应内容
            response_body = req.get_response_body()
            response_content = ""
            if response_body is not None:
                try:
                    response_content = response_body.decode('utf-8', errors='ignore')
                except:
                    response_content = str(response_body)
            
            # 请求headers
            request_headers = {}
            if self.include_headers:
                try:
                    request_headers = dict(req.get_request_headers())
                except:
                    request_headers = {}
            
            # 解析路径
            from urllib.parse import urlparse
            try:
                parsed_url = urlparse(url)
                path = parsed_url.path
            except Exception as e:
                self.logger.warning(f"URL解析失败: {url}, 错误: {e}")
                path = "/"
            
            # 提取域名信息
            domain = parsed_url.hostname if parsed_url.hostname else None
            
            return {
                'method': method,
                'url': url,
                'path': path,
                'domain': domain,  # 新增：记录域名
                'request_headers': request_headers,
                'response_content': response_content,
                'response_status': status,
                'response_size': len(response_content) if response_content else 0
            }
            
        except Exception as e:
            self.logger.error(f"处理单个流量失败: {str(e)}")
            return None
    
    def _analyze_with_rules_engine(self, req):
        """使用规则引擎分析流量 - 使用与原脚本相同的接口"""
        try:
            url = req.get_url()
            
            # 获取请求headers
            headers = {}
            try:
                headers = dict(req.get_request_headers())
            except:
                headers = {}
            
            # 获取响应内容
            response_body = req.get_response_body()
            content = ""
            if response_body is not None:
                try:
                    content = response_body.decode('utf-8', errors='ignore')
                except:
                    content = str(response_body)
            
            # 应用规则引擎
            analysis_result = self.rules_engine.extract_balance_data(
                url=url,
                content=content, 
                headers=headers
            )
            
            return analysis_result
            
        except Exception as e:
            self.logger.error(f"规则引擎分析失败: {str(e)}")
            return None
    
    def _enhance_endpoint_with_balance_data(self, endpoint_data, balance_analysis):
        """使用余额分析结果增强endpoint数据"""
        endpoint_data['balance_analysis'] = balance_analysis
        
        # 添加银行信息
        bank_info = balance_analysis.get('bank_info', {})
        if bank_info:
            endpoint_data['x-bank-region'] = bank_info.get('region')
            endpoint_data['x-bank-type'] = bank_info.get('type')
            endpoint_data['x-api-category'] = bank_info.get('api_category')
        
        # 添加域名信息（用于后续生成服务器配置）
        if 'domain' in endpoint_data:
            endpoint_data['x-server-domain'] = endpoint_data['domain']
        
        # 添加提取的余额信息
        balances = balance_analysis.get('extracted_balances', [])
        if balances:
            endpoint_data['x-extracted-balances'] = balances
            endpoint_data['x-currencies-found'] = list(set(b.get('currency') for b in balances))
        
        # 添加质量指标
        quality_metrics = balance_analysis.get('quality_metrics', {})
        if quality_metrics:
            endpoint_data['x-quality-score'] = quality_metrics.get('quality_score', 0.0)
        
        # 添加置信度
        endpoint_data['x-overall-confidence'] = balance_analysis.get('overall_confidence', 0.0)
        
        return endpoint_data
    
    def _add_endpoint_to_swagger(self, swagger_spec, endpoint_data):
        """将endpoint添加到swagger规范"""
        method = endpoint_data['method'].lower()
        path = endpoint_data['path']
        
        # 确保paths存在
        if 'paths' not in swagger_spec:
            swagger_spec['paths'] = {}
        
        if path not in swagger_spec['paths']:
            swagger_spec['paths'][path] = {}
        
        # 创建操作定义
        operation = {
            'summary': f"{method.upper()} {path}",
            'description': f"Auto-generated from mitmproxy capture",
            'responses': {
                '200': {
                    'description': 'Successful response',
                    'content': {
                        'text/html': {
                            'schema': {'type': 'string'}
                        }
                    }
                }
            }
        }
        
        # 添加银行相关信息
        if 'x-bank-region' in endpoint_data:
            operation['x-bank-region'] = endpoint_data['x-bank-region']
        if 'x-bank-type' in endpoint_data:
            operation['x-bank-type'] = endpoint_data['x-bank-type']
        if 'x-api-category' in endpoint_data:
            operation['x-api-category'] = endpoint_data['x-api-category']
        if 'x-server-domain' in endpoint_data:
            operation['x-server-domain'] = endpoint_data['x-server-domain']
        
        # 添加余额相关信息
        if 'x-extracted-balances' in endpoint_data:
            operation['x-extracted-balances'] = endpoint_data['x-extracted-balances']
            operation['x-currencies-found'] = endpoint_data['x-currencies-found']
            
            # 如果有余额数据，添加专门的响应模式
            operation['responses']['200']['content']['application/json'] = {
                'schema': {
                    'type': 'object',
                    'properties': {
                        'balances': {
                            'type': 'array',
                            'items': {'$ref': '#/components/schemas/BalanceData'}
                        }
                    }
                }
            }
        
        # 添加质量指标
        if 'x-quality-score' in endpoint_data:
            operation['x-quality-score'] = endpoint_data['x-quality-score']
        if 'x-overall-confidence' in endpoint_data:
            operation['x-overall-confidence'] = endpoint_data['x-overall-confidence']
        
        # 如果包含示例
        if self.include_examples and 'response_content' in endpoint_data:
            # 截取前1000字符作为示例
            example_content = endpoint_data['response_content'][:1000]
            if 'examples' not in operation['responses']['200']['content']['text/html']:
                operation['responses']['200']['content']['text/html']['examples'] = {}
            operation['responses']['200']['content']['text/html']['examples']['default'] = {
                'value': example_content
            }
        
        swagger_spec['paths'][path][method] = operation
    
    def _add_stats_to_swagger(self, swagger_spec):
        """添加统计信息到swagger规范"""
        swagger_spec['info']['x-analysis-stats'] = {
            'total_flows': self.stats['total_flows'],
            'processed_flows': self.stats['processed_flows'],
            'balance_apis_found': self.stats['balance_apis_found'],
            'extraction_success_rate': (
                self.stats['extraction_success'] / max(self.stats['processed_flows'], 1)
            ),
            'currencies_detected': list(self.stats['currencies_detected']),
            'banks_detected': list(self.stats['banks_detected'])
        }
        
        # 基于通用规则动态生成服务器信息
        self._generate_servers_from_detected_banks(swagger_spec)
    
    def _generate_servers_from_detected_banks(self, swagger_spec):
        """基于检测到的银行信息动态生成服务器配置"""
        servers = []
        detected_domains = set()
        
        # 从实际处理的流量中提取域名信息
        for path, methods in swagger_spec.get('paths', {}).items():
            for method, operation in methods.items():
                if isinstance(operation, dict) and 'x-bank-region' in operation:
                    bank_region = operation.get('x-bank-region')
                    
                    # 从实际的endpoint数据中提取域名（如果有的话）
                    domain = self._extract_domain_from_operation(operation, path)
                    if domain and domain not in detected_domains:
                        description = self._generate_server_description(domain, bank_region)
                        servers.append({
                            'url': f"https://{domain}",
                            'description': description
                        })
                        detected_domains.add(domain)
        
        if servers:
            swagger_spec['servers'] = servers
    
    def _extract_domain_from_operation(self, operation, path):
        """从操作信息中提取域名 - 完全基于实际数据"""
        # 从operation的扩展信息中获取域名
        return operation.get('x-server-domain')
    
    def _generate_server_description(self, domain, bank_region):
        """基于通用规则生成服务器描述"""
        # 通用的区域名称映射
        region_names = {
            'hk_banks': 'Hong Kong Banking',
            'cn_banks': 'Mainland China Banking', 
            'sg_banks': 'Singapore Banking',
            'us_banks': 'US Banking',
            'eu_banks': 'European Banking',
            'jp_banks': 'Japan Banking'
        }
        
        region_name = region_names.get(bank_region, 'Banking')
        
        # 基于域名特征增加更多上下文（通用规则，不硬编码具体银行）
        domain_lower = domain.lower()
        if 'wing' in domain_lower or 'cmb' in domain_lower:
            context = ' (Wing Lung Branch)'
        elif 'boc' in domain_lower:
            context = ' (BOC Branch)'
        elif 'hsbc' in domain_lower:
            context = ' (HSBC Branch)'
        elif 'dbs' in domain_lower:
            context = ' (DBS Branch)'
        elif 'bank' in domain_lower:
            context = ' (Banking Service)'
        else:
            context = ''
        
        return f"{region_name}{context} API Server"


def universal_main(override_args: Optional[Sequence[str]] = None):
    """通用主函数"""
    logger = setup_logging()
    
    parser = argparse.ArgumentParser(
        description="Universal mitmproxy2swagger with enhanced balance extraction using rule-based engine."
    )
    parser.add_argument(
        "-i", "--input",
        help="The input mitmproxy dump file or HAR dump file",
        required=True
    )
    parser.add_argument(
        "-o", "--output", 
        help="The output swagger schema file (yaml)",
        required=True
    )
    parser.add_argument(
        "-p", "--api-prefix",
        help="The api prefix (optional, will auto-detect if not provided)",
        required=False
    )
    parser.add_argument(
        "-e", "--examples",
        action="store_true",
        help="Include examples in the schema"
    )
    parser.add_argument(
        "-hd", "--headers",
        action="store_true", 
        help="Include headers in the schema"
    )
    parser.add_argument(
        "-f", "--format",
        choices=["flow", "har"],
        help="Override the input file format auto-detection"
    )
    parser.add_argument(
        "--extract-balance",
        action="store_true",
        help="Enable balance data extraction using universal rules engine"
    )
    parser.add_argument(
        "--balance-report",
        help="Generate detailed balance extraction report to specified file"
    )
    parser.add_argument(
        "--confidence-threshold",
        type=float,
        default=0.3,
        help="Minimum confidence threshold for balance extraction (0.0-1.0)"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose logging"
    )

    args = parser.parse_args(override_args)
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    logger.info(f"开始处理: {args.input} -> {args.output}")
    
    try:
        # 确定输入文件格式
        if args.format:
            file_format = args.format
        else:
            if har_archive_heuristic(args.input):
                file_format = "har"
            elif mitmproxy_dump_file_huristic(args.input):
                file_format = "flow"
            else:
                logger.error("无法确定输入文件格式")
                return 1
        
        logger.info(f"检测到文件格式: {file_format}")
        
        # 读取现有的swagger规范（如果存在）
        existing_swagger = None
        if os.path.exists(args.output):
            try:
                with open(args.output, 'r', encoding='utf-8') as f:
                    yaml_loader = ruamel.yaml.YAML()
                    existing_swagger = yaml_loader.load(f)
                logger.info("加载了现有的swagger规范")
            except Exception as e:
                logger.warning(f"无法加载现有swagger规范: {str(e)}")
        
        # 创建生成器
        generator = UniversalSwaggerGenerator(
            include_examples=args.examples,
            include_headers=args.headers
        )
        
        # 读取并处理flows
        if file_format == "har":
            reader = HarCaptureReader(args.input)
        else:
            reader = MitmproxyCaptureReader(args.input)
        
        # 直接获取flows，不提前计数（避免消费生成器）
        flows = reader.captured_requests()
        logger.info("开始读取流量数据...")
        
        # 处理flows并生成swagger
        swagger_spec = generator.process_flows(flows, existing_swagger)
        
        # 保存swagger规范
        output_path = Path(args.output)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(args.output, 'w', encoding='utf-8') as f:
            yaml_dumper = ruamel.yaml.YAML()
            yaml_dumper.default_flow_style = False
            yaml_dumper.dump(swagger_spec, f)
        
        logger.info(f"Swagger规范已保存到: {args.output}")
        
        # 生成余额提取报告
        if args.balance_report:
            report_data = {
                'analysis_summary': swagger_spec['info'].get('x-analysis-stats', {}),
                'generation_time': datetime.now().isoformat(),
                'input_file': args.input,
                'output_file': args.output,
                'configuration': {
                    'confidence_threshold': args.confidence_threshold,
                    'include_examples': args.examples,
                    'include_headers': args.headers
                }
            }
            
            with open(args.balance_report, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"余额提取报告已保存到: {args.balance_report}")
        
        # 打印统计信息
        stats = swagger_spec['info'].get('x-analysis-stats', {})
        print(f"\n=== 分析统计 ===")
        print(f"总流量数: {stats.get('total_flows', 0)}")
        print(f"处理流量数: {stats.get('processed_flows', 0)}")
        print(f"发现余额API: {stats.get('balance_apis_found', 0)}")
        print(f"提取成功率: {stats.get('extraction_success_rate', 0):.2%}")
        print(f"检测到货币: {', '.join(stats.get('currencies_detected', []))}")
        print(f"检测到银行: {', '.join(stats.get('banks_detected', []))}")
        
        return 0
        
    except Exception as e:
        logger.error(f"处理过程中出现错误: {str(e)}")
        if args.verbose:
            logger.debug(traceback.format_exc())
        return 1


if __name__ == "__main__":
    sys.exit(universal_main())